## Generates a sine/cosine wave function and optionally applies it to the position of the parent Entity's node every frame, resulting in a wave-like movement along an axis, or a circular motion if both axes are used.
## NOTE: Sets the parent entity's position DIRECTLY; does NOT use "physics" such as [member CharacterBody2D.velocity].
## TIP: This component is a [Node2D] so it may itself be moved without affecting the Entity, and have visual child nodes etc. This may be useful for having "drones" around the player etc.

class_name WaveMotionComponent
extends Component


#region Parameters

## If `true` then a COSINE [method @GlobalScope.cos] wave function is used for the horizontal X value, which allows a circular motion when combined with a sine wave for the vertical Y value.
## If `false` (default), a SINE wave is used for the horizontal X value, so that it always starts at 0 and ensures a smooth offset from a node's current position.
## NOTE: Using sine waves for BOTH X & Y results in a diagonal cycle.
@export var shouldUseCosineForX: bool = false

## The horizontal range of the sine/cosine wave motion, effectively the distance in pixels (hence the granularity of 1.0) from the "trough" -[member xAmplitude] of the wave to the "peak" +[member xAmplitude].
## NOTE: Unless [member shouldUseCosineForX] is `true`, a SINE wave is used for the horizontal movement; NOT a cosine wave, because sine always starts at 0.
@export_range(-1000, +1000, 1)		var xAmplitude: float = 0
@export_range(-100,	  100,	0.05)	var xFrequency: float = 0 ## The number of times during 1 second for the horizontal wave to go from -[member xAmplitude] to +[member xAmplitude]. i.e. a frequency of 0.5 will take 2 seconds.

@export_range(-1000, +1000, 1)		var yAmplitude: float = 64 ## The vertical range of the sine wave motion, effectively the distance in pixels (hence the granularity of 1.0) from the "peak" -[member yAmplitude] of the wave to the "trough" +[member yAmplitude].
@export_range(-100,	  100,	0.05)	var yFrequency: float = 1  ## The number of times during 1 second for the vertical wave to go from -[member yAmplitude] to +[member yAmplitude]. i.e. a frequency of 0.5 will take 2 seconds.

@export var nodeToMove: Node2D ## If not specified, the parent Entity will be used.

@export var isEnabled: bool = true:
	set(newValue):
		isEnabled = newValue
		self.set_physics_process(isEnabled)

#endregion


#region State
var time:			float ## Each component instance has its own time. Starts at 0 and increments by the frame `delta`
var wavePosition:	Vector2 ## The current position on the waveform being generated by the parameters. May be applied as an offset to the Entity's position or some other data etc.
var previousWavePosition: Vector2 ## The value of [member wavePosition] in the previous frame. (0,0) on the first frame.
var waveDelta:		Vector2 ## The difference between the current [member wavePosition] and the [member previousWavePosition]. Node positions etc. must be offset by this value.

var secondsToMaxAmplitudeX: float ## For logging & debugging
var secondsToMaxAmplitudeY: float ## For logging & debugging
#endregion


func _ready() -> void:
	if not nodeToMove: nodeToMove = parentEntity
	self.set_physics_process(isEnabled) # Apply setter because Godot doesn't on initialization


func _physics_process(delta: float) -> void:
	# NOTE: SOLVED: Problem Example Parameters: yAmplitude:64
	# Adding directly with `position.y += wave.y * delta` gives an almost-pixel-perfect position range but it's doubled: from 0 to +128,
	# WHY: because the generated wave goes up to +64 then back down to 0, so the wave's value is +64 and AGAIN +64 MORE units!
	# SOLUTION: So we just take the delta i.e. instant DIRECTION (or derivative?) of the wave and offset the Entity's position by the DIFFERENCE! instead of the absolute value
	# TRIED: Using `cos` for Y gives a Y range of -63.45~ to +64.5~ which is not pixel-perfect

	time += delta # Let each component instance start at 0 and have its own wave phase. Also `Time.get_ticks_msec()` doesn't work right

	previousWavePosition = wavePosition

	# Store the wave separately for use by other scripts etc.
	if shouldUseCosineForX:
		wavePosition = Vector2(
			cos(time * (PI * xFrequency)) * xAmplitude,
			sin(time * (PI * yFrequency)) * yAmplitude)
	else:
		wavePosition = Vector2(
			sin(time * (PI * xFrequency)) * xAmplitude, # NOTE: Use a sine wave for the horizontal X component too because sine starts at 0!
			sin(time * (PI * yFrequency)) * yAmplitude)

	# Get the wave "direction"
	waveDelta = wavePosition - previousWavePosition

	# Move the node by the "derivative" of the wave (TBD: is "derivative" the correct word to use here? ^^")
	nodeToMove.position += waveDelta
	nodeToMove.reset_physics_interpolation() # CHECK: Is this necessary?
	
	# DEBUG: if debugMode: showDebugInfo(delta)


#region Debugging

func showDebugInfo(delta: float) -> void:
	if not debugMode: return

	secondsToMaxAmplitudeX += delta
	if not is_zero_approx(xAmplitude) and is_equal_approx(abs(nodeToMove.position.x), abs(xAmplitude)):
		Debug.printVariables([parentEntity.name, time, "Seconds to X:", secondsToMaxAmplitudeX, wavePosition.x, nodeToMove.position.x])
		secondsToMaxAmplitudeX = 0

	secondsToMaxAmplitudeY += delta
	if not is_zero_approx(yAmplitude) and is_equal_approx(abs(nodeToMove.position.y), abs(yAmplitude)):
		Debug.printVariables([parentEntity.name, time, "Seconds to Y:", secondsToMaxAmplitudeY, wavePosition.y, nodeToMove.position.y])
		secondsToMaxAmplitudeY = 0

#endregion
