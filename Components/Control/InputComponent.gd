## A unified source of control input for other components to act upon. The source may be a meatspace player or AI agent script or a "demo/attract" recording etc.
## ALERT: Does NOT check mouse motion input.
## NOTE: To improve performance, small independent components may do their own input polling. Therefore, this [InputComponent] makes most sense when a chain of multiple components depend upon it, such as [TurningControlComponent] + [ThrustControlComponent].
## TIP: May be subclassed for AI-control or pre-recorded demos or "attract mode" etc.
## Requirements: AFTER (below in the Scene Tree) all components that depend on player/AI control, because input events propagate from the BOTTOM of the Scene Tree nodes list UPWARD.

class_name InputComponent
extends Component


#region Parameters

## Disables all input processing & updates.
@export var isEnabled: bool = true:
	set(newValue):
		if newValue != isEnabled:
			isEnabled = newValue
			self.setProcess()

## If `false` then system input events are not processed,
## but this component may still be manually modified and used by other components, such as AI agents or demo scripts.
## [method handleInput] & [method updateInputActionsPressed] may be called manually at any time,
## e.g. to process synthetic [InputEvent]s generated by gameplay code.
@export var isPlayerControlled: bool = true:
	set(newValue):
		if newValue != isPlayerControlled:
			isPlayerControlled = newValue
			self.setProcess()

## If `true` (default) then only [method Node._unhandled_input] is processed to catch the input events that are NOT consumed by other components/scripts/nodes.
## If `false` then [method Node._input] is processed, to catch ALL events, even if they were already handled by other nodes.
@export var shouldProcessUnhandledInputOnly: bool = true:
	set(newValue):
		if newValue != shouldProcessUnhandledInputOnly:
			shouldProcessUnhandledInputOnly = newValue
			self.setProcess()

## If `true`, then [InputEvent]s are prevented from bubbling up the Scene Tree if they include any of the input actions processed by this component, such as movement, jumping, shooting etc.
## May improve performance.
## ALERT: This will prevent any OTHER [InputComponent]s from receiving events! Use this when ONLY ONE character should be controlled.
@export var shouldSetEventsAsHandled: bool = false # DESIGN: Let's default to `false` because disabling event propagation should be an explicit decision: we may forget about it and wonder why other scripts aren't receiving input.

## Multiplies each of the [param movementDirection]'s axes, i.e. the primary movement control, including the Left Joystick & D-pad.
## TIP: Negative values invert player/AI control. e.g. (-1, 1) will flip the horizontal walking direction.
@export var movementDirectionScale:	Vector2 = Vector2.ONE

## Multiplies each of the [param lookDirection]'s axes, which is usually provided by the Right Joystick.
## TIP: Negative values invert the camera control, e.g. (1, -1) will flip the vertical camera axis.
@export var lookDirectionScale:		Vector2 = Vector2.ONE

## The list of input actions to watch for and include in [member inputActionsPressed].
## Because dummy Godot doesn't let us directly get all the input actions from an [InputEvent],
## we have to manually check every possibility, so here we shorten that list of possible events.
const inputActionsToMonitor: PackedStringArray = [
	GlobalInput.Actions.jump,
	GlobalInput.Actions.fire,
	GlobalInput.Actions.interact,
	]

#endregion


#region State
# TBD: @export_storage

## A list of all the input actions from [const inputActionsToMonitor] that are currently pressed.
var inputActionsPressed: PackedStringArray

var previousMovementDirection:	Vector2
var movementDirection:			Vector2: ## The primary movmeent input from the combined horizontal + vertical axes. Includes the Left Joystick & the D-pad.
	set(newValue):
		if newValue != movementDirection:
			# NOTE: Do not count "echoes" (repeated events generated when the same input is pressed and held) as changes in the input!
			if not lastInputEvent.is_echo(): previousMovementDirection = movementDirection
			movementDirection = newValue

var horizontalInput:	float ## The primary X axis. Includes the Left Joystick & the D-pad.
var verticalInput:		float ## The primary Y axis. Includes the Left Joystick & the D-pad.

var lookDirection:		Vector2 ## The Right Joystick.
var turnInput:			float ## The horizontal X axis for the Left Joystick ONLY (NOT D-pad). May be identical to [member horizontalInput]
var thrustInput:		float ## The vertical Y axis for the Left Joystick ONLY (NOT D-pad). May be the INVERSE of [member verticalInput] because Godot's Y axis is negative for UP, but for joystick input UP is POSITIVE.

var lastNonzeroHorizontalInput:	float ## The last NON-ZERO [member horizontalInput] received. May be used to determine where a character should be facing etc.
var lastNonzeroVerticalInput:	float ## The last NON-ZERO [member verticalInput] received. May be used to determine where a character should be facing etc.

var lastInputEvent:		InputEvent ## The most recent [InputEvent] received by [method handleInput]. NOTE: Only input "action" events where [method InputEvent.is_action_type] are included.

## If `true`, then the next [method _input] or [method _unhandled_input] is skipped ONCE, and then this flag is reset.
## May be used to temporarily suppress player control, e.g. to implement automatic/scripted movement etc.
var shouldSkipNextEvent:bool = false

#endregion


#region Signals
# TBD: Signals for axis updates?
signal didProcessInput(event: InputEvent)
signal didUpdateInputActionsList ## Emitted when the list of [member inputActionsPressed] is updated.

## Emitted when [member movementDirection] and [member previousMovementDirection] have a different SIGN (positive/negative) on the X axis, signifying a change/flip in direction from right ↔ left.
## May be used for sprite flipping and other animations etc.
signal didChangeHorizontalDirection

## Emitted when [member movementDirection] and [member previousMovementDirection] have a different SIGN (positive/negative) on the Y axis, signifying a change/flip in direction from up ↔ down.
## May be used for sprite flipping and other animations etc.
signal didChangeVerticalDirection
#endregion


#region Initialization

func _ready() -> void:
	# Update the input actions that were pressed/released BEFORE this component is ready.
	updateInputActionsPressed()
	setProcess() # Apply setters because Godot doesn't on initialization


## Enables or disables the per-frame and event process based on flags.
func setProcess() -> void:
	self.set_process(debugMode)
	self.set_process_input(isEnabled and isPlayerControlled and not shouldProcessUnhandledInputOnly)
	self.set_process_unhandled_input(isEnabled and isPlayerControlled and shouldProcessUnhandledInputOnly)

#endregion


#region Update

## Affected by [member isEnabled], [member isPlayerControlled] and [member shouldProcessUnhandledInputOnly].
## May be skipped ONCE by [member shouldSkipNextEvent].
func _input(event: InputEvent) -> void:
	# Checked by property setters: if isEnabled and not shouldProcessUnhandledInputOnly:
	if event is InputEventMouseMotion: return
	if shouldSkipNextEvent:
		shouldSkipNextEvent = false
		return
	if debugMode: printDebug(str("_input(): ", event))
	handleInput(event)


## Affected by [member isEnabled], [member isPlayerControlled] and [member shouldProcessUnhandledInputOnly].
## May be skipped ONCE by [member shouldSkipNextEvent].
func _unhandled_input(event: InputEvent) -> void:
	# Checked by property setters: if isEnabled and shouldProcessUnhandledInputOnly:
	if event is InputEventMouseMotion: return
	if shouldSkipNextEvent:
		shouldSkipNextEvent = false
		return
	if debugMode: printDebug(str("_unhandled_input(): ", event))
	handleInput(event)


## Affected by [member isEnabled] but NOT affected by [member isPlayerControlled], to allow control by AI/code.
## NOTE: NOT affected by [member shouldSkipNextEvent], to allow manual processing of synthetic [InputEvent]s etc.
func handleInput(event: InputEvent) -> void:
	# NOTE: For joystick input, events will be raised TWICE: once for both the X and Y axes.

	if not isEnabled or not event.is_action_type(): return
	self.lastInputEvent = event

	if updateInputActionsPressed(event) and shouldSetEventsAsHandled:
		self.get_viewport().set_input_as_handled()

	# TBD: CHECK: PERFORMANCE: Use a bunch of `if`s to update state properties only when there is a relevant matching input event?

	# NOTE: Do NOT check is_action_pressed() or is_action_released()
	# because even if 1 directional input is pressed/released, an entire axis must be updated from the state of 2 input actions.
	# Analog joystick fractional input strengths must also be accounted for.
	if event.is_action(GlobalInput.Actions.moveLeft)	\
	or event.is_action(GlobalInput.Actions.moveRight)	\
	or event.is_action(GlobalInput.Actions.moveUp)		\
	or event.is_action(GlobalInput.Actions.moveDown):

		self.movementDirection	= Input.get_vector(GlobalInput.Actions.moveLeft, GlobalInput.Actions.moveRight, GlobalInput.Actions.moveUp, GlobalInput.Actions.moveDown) * movementDirectionScale
		# TBD: Get the individual axes again or just copy from `movementDirection`?
		self.horizontalInput	= Input.get_axis(GlobalInput.Actions.moveLeft,	 GlobalInput.Actions.moveRight) * movementDirectionScale.x
		self.verticalInput		= Input.get_axis(GlobalInput.Actions.moveUp,	 GlobalInput.Actions.moveDown)  * movementDirectionScale.y

		if not is_zero_approx(horizontalInput): lastNonzeroHorizontalInput = horizontalInput
		if not is_zero_approx(verticalInput):	lastNonzeroVerticalInput   = verticalInput

		if signf(previousMovementDirection.x) != signf(movementDirection.x):
			if debugMode: printDebug(str("didChangeHorizontalDirection: ", previousMovementDirection.x, " → ", movementDirection.x))
			didChangeHorizontalDirection.emit()

		if signf(previousMovementDirection.y) != signf(movementDirection.y):
			if debugMode: printDebug(str("didChangeVerticalDirection: ", previousMovementDirection.y, " → ", movementDirection.y))
			didChangeVerticalDirection.emit()

		if shouldSetEventsAsHandled: self.get_viewport().set_input_as_handled()

	self.lookDirection	= Input.get_vector(GlobalInput.Actions.lookLeft, GlobalInput.Actions.lookRight, GlobalInput.Actions.lookUp, GlobalInput.Actions.lookDown) * lookDirectionScale
	self.turnInput		= Input.get_axis(GlobalInput.Actions.turnLeft, 	 GlobalInput.Actions.turnRight)
	self.thrustInput	= Input.get_axis(GlobalInput.Actions.moveBackward, GlobalInput.Actions.moveForward)

	# TODO: self.get_viewport().set_input_as_handled() for the other input actions we handled.

	if debugMode: showDebugInfo()
	didProcessInput.emit(event)


## Updates [member inputActionsPressed].
## Affected by [member isEnabled] but NOT affected by [member isPlayerControlled], to allow control by AI/code.
## Returns `true` if [param event] contains one of the input actions included in [const inputActionsToMonitor].
func updateInputActionsPressed(event: InputEvent = null) -> bool:
	if not isEnabled: return false

	# DESIGN: Do NOT just listen for `event.is_action_pressed()` etc., poll the state of ALL input actions,
	# to make sure that [inputActionsPressed] also includes input actions that were pressed BEFORE this component received its first event.

	# TBD: CHECK: PERFORMANCE: What's faster? Just create a new array each time or modify an existing one?
	var inputActionsPressedNew: PackedStringArray
	var isEventMonitored: bool # Does the received InputEvent include one of the input actions we monitor?

	for inputActionToMonitor: StringName in inputActionsToMonitor:
		if Input.is_action_pressed(inputActionToMonitor):
			inputActionsPressedNew.append(inputActionToMonitor)

		if event and event.is_action(inputActionToMonitor): isEventMonitored = true

	# Did we consume an InputEvent for one of the input actions we monitor?
	if isEventMonitored:
		self.inputActionsPressed = inputActionsPressedNew
		didUpdateInputActionsList.emit()

	return isEventMonitored

#endregion


#region Debugging

func _process(_delta: float) -> void:
	if debugMode: showDebugInfo()


func showDebugInfo() -> void:
	# if not debugMode: return # Checked by caller
	Debug.addComponentWatchList(self, {
		actionsPressed		= inputActionsPressed,
		previousMovementDirection = previousMovementDirection,
		movementDirection	= movementDirection,
		lookDirection		= lookDirection,
		horizontalInput		= horizontalInput,
		verticalInput		= verticalInput,
		turnInput			= turnInput,
		thrustInput			= thrustInput
		})

#endregion
