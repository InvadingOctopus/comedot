## Receives player input and calls [method ActionsComponent.performAction] to perform an [Action].
## An [Action] may be a special skill like "Heal", or a spell like "Fireball", or a trivial command like "Examine".
## Some actions may require a target entity or object to chosen, and may cost a [Stat] to be used.
## If the [ActionsComponent] requests a target, then a subclass of [ActionTargetingComponentBase] is added to the Entity to prompt the player to choose a target.
## To display UI buttons for Actions, use [ActionButtons] & [ActionButtonsList].
## TIP: To execute Actions via keyboard shortcuts or gamepad buttons, edit the Project Settings' Input Map,
## and add Godot input actions with names matching [member GlobalInput.Actions.specialActionPrefix] + [member Action.name] e.g. `specialAction_dash`.
## Requirements: [ActionsComponent]

class_name ActionControlComponent
extends Component


#region Parameters
## A subclass of [ActionTargetingComponentBase] to add to the parent [Entity] to present a UI to the player for choosing a target for [Action]s which require a target, such as a "Fireball" spell or a "Talk" command.
@export_file("*ActionTargeting*Component.tscn") var targetingComponentPath: String = "res://Components/Control/ActionTargetingPositionComponent.tscn" # Exclude the abstract "Base" components.

@export var isEnabled: bool = true:
	set(newValue):
		if newValue != isEnabled:
			isEnabled = newValue
			self.set_process_input(isEnabled)
			self.set_process_unhandled_input(isEnabled)

#endregion


#region Signals
# In ActionsComponent
#endregion


#region Dependencies

@onready var actionsComponent: ActionsComponent = coComponents.ActionsComponent # TBD: Static or dynamic?

func getRequiredComponents() -> Array[Script]:
	return [ActionsComponent]

#endregion


#region Input & Execution

## Handles "synthetic" [InputEventAction] events generated by [ActionButton] etc.
func _input(event: InputEvent) -> void:
	if not isEnabled or not event is InputEventAction: return

	# Just get an Action's name, if any, and forward it to ActionsComponent.performAction()

	var eventAction: InputEventAction = event as InputEventAction
	var eventName:   StringName = eventAction.action
	if debugMode: printDebug("_input() eventName: " + eventName)

	# Is it a "special" Action? # TBD: Less ambiguous name? :')
	# NOTE: Compare in lowercase to reduce typos/mistakes/bugs
	if not eventName.to_lower().begins_with(GlobalInput.Actions.specialActionPrefix.to_lower()): return

	var actionName: StringName = eventName.trim_prefix(GlobalInput.Actions.specialActionPrefix)
	if  actionsComponent: actionsComponent.performAction(actionName)


func _unhandled_input(event: InputEvent) -> void:
	# TBD: Execute Action shorts on press or on release?
	# TBD: According to Godot documentation: "For keyboard shortcuts, consider using _shortcut_input() instead, as it is called before this method. Finally, to handle keyboard events, consider using _unhandled_key_input() for performance reasons."

	if not isEnabled or not event.is_action_type() or not event.is_pressed(): return

	if actionsComponent:
		# See if a keyboard shortcut or gamepad button etc. matches any Action, and execute it
		var action: Action = actionsComponent.findActionForInputEvent(event)
		if  action:
			actionsComponent.performAction(action.name)
			self.get_viewport().set_input_as_handled()


#endregion


#region Target Selection

func _ready() -> void:
	Tools.connectSignal(actionsComponent.didRequestTarget, self.onActionsComponent_didRequestTarget)


func onActionsComponent_didRequestTarget(action: Action, source: Entity) -> void:
	if debugMode: printDebug(str("onActionsComponent_didRequestTarget() ", action, ", source: ", source))
	if source == self.parentEntity: createTargetingComponent(action) # Create & add a component which prompt the player to choose a target.
	else: printDebug(str("Action source: ", source, " is not parentEntity: ", parentEntity))


func createTargetingComponent(actionToPerform: Action) -> ActionTargetingComponentBase:
	var componentScene: PackedScene = load(targetingComponentPath)
	var targetingComponent: ActionTargetingComponentBase = componentScene.instantiate()

	if not targetingComponent:
		printWarning(str("Cannot instantiate a subclass of ActionTargetingComponentBase: ", targetingComponentPath))
		return null

	targetingComponent.action = actionToPerform
	parentEntity.addComponent(targetingComponent)
	# GlobalUI.actionDidRequestTarget.emit(actionToPerform, parentEntity) # This should be emitted by ActionsComponent next to its `didRequestTarget` as that's the first point where a target is requested.
	return targetingComponent

#endregion
