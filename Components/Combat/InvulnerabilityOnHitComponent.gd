## Grants temporary immunity to damage after the Entity's [DamageReceivingComponent] takes damage.
## Useful for combat systems based on "lives"; a finite number of discrete hits that the player can take.

class_name InvulnerabilityOnHitComponent
extends Component


# NOTE: DESIGN: Why not use a [HealthComponent]?
# Because a [HealthComponent] may lose health from damage-over-time sources like poison.
# This kind of "temporary invulnerability" is intended for damage from enemies, for now.

# TODO: Proper animations for visual effects

#region Parameters
@export var isEnabled := true
#endregion


#region Signals
signal didStartInvulnerability
signal didEndInvulnerability
#endregion


#region State

@onready var timer: Timer = $InvulnerabilityTimer

var isActive: bool:
	get:
		return not timer.is_stopped()

var damageReceivingComponent: DamageReceivingComponent:
	get: return self.findCoComponent(DamageReceivingComponent)

#endregion


func _ready():
	damageReceivingComponent.didReceiveDamage.connect(self.damageReceivingComponent_didReceiveDamage)


func damageReceivingComponent_didReceiveDamage(amount: int, attackerFactions: int):
	if not isEnabled: return

	# TBD: Activat invulnerability only if there is some actual damage.
	if amount <= 0: return

	startInvulnerability()


func onTimerTimeout() -> void:
	endInvulnerability()


func startInvulnerability():
	timer.start()
	damageReceivingComponent.isEnabled = false

	# Avoid cases where damage-per-second seems too quick when invulnerability ends.
	# TBD: Should this be handled a better way?
	damageReceivingComponent.accumulatedFractionalDamage = 0

	parentEntity.modulate = Color.GREEN
	didStartInvulnerability.emit()


func endInvulnerability():
	timer.stop()
	damageReceivingComponent.isEnabled = true
	parentEntity.modulate = Color.WHITE
	didEndInvulnerability.emit()


